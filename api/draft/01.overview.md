# REST简介
传统的RPC API演化的最终结果可能就是存在大量的接口和方法，每个都与其他方法不同。开发人员必须仔细地学习每一个，才能正确使用它。这既耗时又容易出错。

Roy Fielding于2000年首次提出了[REST](https://en.wikipedia.org/wiki/Representational_state_transfer)作为设计Web服务的架构风格。其核心原则是定义可使用少量方法操作的命名资源(resource names)。资源和方法被称为API的名词和动词。

REST独立于任何底层协议，不一定与HTTP绑定。但是，大多数常见的REST实现使用HTTP作为应用程序协议。基于HTTP的REST的主要优点是它使用开放标准，并且针对API实现或客户端应用程序，它不绑定任何特定的实现。使用HTTP协议，资源名称自然映射到URL，方法自然映射到HTTP方法。

以下是使用HTTP的RESTful API的一些主要设计原则：  
- REST API是围绕资源设计的，这些资源是客户端可以访问的任何类型的对象，数据或服务。
- 资源具有标识符（identifier），该标识符就是唯一标识该资源的URI。 例如：  
```
# 特定销售订单
https://apis.newegg.org/so/v1/orders/12345678
# 某个客人的所有订单
https://apis.newegg.org/so/v1/customers/167498/orders
```
- 客户通过交换资源表示（representations of resources）来与服务交互。
- REST API使用统一的接口（uniform interface），这有助于分离客户端和服务实现。 对于构建于HTTP上的REST API，统一接口包括使用标准HTTP动词对资源执行操作。 最常见的操作是GET，POST，PUT，PATCH和DELETE。
- REST API使用无状态请求模型（stateless request model）。 HTTP请求应该是独立的，并且可以以任何顺序发生，因此在请求之间保持瞬态状态信息是不可行的。 唯一存储信息的地方是资源本身，每个请求都应该是原子操作。 这个约束使Web服务具有高度的可伸缩性，因为不需要保留客户端和特定服务器之间的任何关联（affinity）。 任何服务器都可以处理任何客户端的请求。 虽说如此，其他因素可能会限制可伸缩性。 例如，许多Web服务写入后端数据存储，这可能难以扩展。
- REST API由表示中包含的超媒体链接驱动。
```
{
    "orderID":3,
    "productID":2,
    "quantity":4,
    "orderValue":16.60,
    "links": [
        {"rel":"product","href":"http://adventure-works.com/customers/3", "action":"GET" },
        {"rel":"product","href":"http://adventure-works.com/customers/3", "action":"PUT" }
    ]
}
```

https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design


# 成熟度模型
2008年，Leonard Richardson为Web API提出了以下成熟度模型：  
- 级别0：定义一个URI，所有的操作都是对这个URI的POST请求。
- 级别1：为单个资源创建单独的URI。
- 级别2：使用HTTP方法来定义资源上的操作。
- 等级3：使用超媒体（HATEOAS）。

根据Fielding的定义，级别3对应一个真正的RESTful API。实际上，许多已发布的Web API都在第2级左右。




- 基于HTTP统一接口的CRUD等操作
- HATEOAS：让一个设计良好的客户端可以像人运行互联网一样运行API

=======================
什么是API？
- 与service不同
- 多个端口
- 合约





## 设计流程  
https://cloud.google.com/apis/design/resources  
建议在设计面向资源的API时采取以下步骤:  
- 确定API提供的资源。
- 确定资源之间的关系。
- 根据类型和关系决定资源名称方案 (resource name schemes)。
- 决定资源模式 (resource schemas)。
- 为资源添加最少的方法。


API Owner
breaking Changes
Resource & Representation


要开发良好的基于HTTP的服务，需理解REST架构风格背后的理念。
一致性不仅对外部客户而且对内部服务消费者也很有价值，而且这些准则提供了对任何服务都有用的最佳实践。

好的API看起来像是一个team开发的

原则：
- API as a product
- API Design Principles

# General guidelines
- Follow API First Principle
- Provide API Specification using OpenAPI
- design based on general requirements

使用RAML定义API；使用Developer portal configure &manage API
owner, 共享，边界
不能是表的翻译


这些准则的豁免有合理的理由。 很明显，实现或必须与某些外部定义的REST API进行互操作的REST服务必须与该API兼容，而不一定是这些指南。 某些服务也可能有特殊的性能需求，需要不同的格式，如二进制协议。

# 错误
错误或者更具体的服务错误被定义为客户机将无效数据传递给服务并且服务正确地拒绝该数据。 示例包括无效的凭据，不正确的参数，未知的版本ID或类似信息。 这些通常是“4xx”HTTP错误代码，并且是客户端传递错误或无效数据的结果。

错误不会影响整个API的可用性。

# 故障
故障或者更具体的服务故障被定义为服务无法正确返回以响应有效的客户端请求。 这些通常是“5xx”HTTP错误代码。

故障确实有助于整体API的可用性。

由于速率限制或配额故障而失败的呼叫绝不能算作故障。 由于服务快速失败请求而失败的调用（通常是为了自己的保护）会被视为错误。

# 延迟
延迟定义为特定API调用需要完成多长时间，尽可能接近客户端进行度量。 这个指标同样适用于同步API和异步API。 对于长时间运行的调用，延迟是在初始请求时测量的，并测量该调用（而非整体操作）需要多长时间才能完成。



# 客户端指南
