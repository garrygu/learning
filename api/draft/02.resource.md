# 面向资源的设计（Resource Oriented Design）
资源是REST架构的基础，是系统中所有可用URI来定位的具体或抽象实体。REST架构中所有的操作都是面向资源的。


## 一般原则
1. 从客户（使用者）的角度出发进行思考和设计。  
2. 面向资源而不是操作。
3. 数据库表或者对象模型和资源不一定是一一对应的。避免创建简单反映数据库内部结构的API。
4. API应该包含完整的业务流程，包含涉及流程的所有资源。这防止API只是数据库的一个简单包装，避免将业务逻辑移往客户端。  
5. 根据资源表现层大小、性能考量、客户习惯和业界规范来决定资源粒度。将适合缓存、不经常变化或不变的数据同很少缓存、经常变化的数据分开。
6. 除去根路径，资源的层级应该<=3。
7. 避免使用GET和POST方法来tunneling其他请求方法。


## 资源（Resource）
面向资源的API通常建模为资源层次结构（resource hierarchy）。其中的每个节点都是简单资源或集合资源，通常分别被称为资源和集合。

- 简单资源   
简称资源。例如客户，订单，客户的一个邮寄地址等。

- 集合资源（collections）   
简称集合。集合包含0到多个相同类型的个体资源。例如，目录是文件资源的集合。又比如客户列表，一个客户的所有订单， 用户的一组联系人等。  
集合是一种特殊的资源，有自己的URI。集合中的每个项目也有自己的唯一URI。

资源有一些状态以及0个或多个子资源。每个子资源也可以是简单资源或集合资源。


## 资源标识（Resource Identifier）
资源是由URI来唯一标识的。URI称为资源的标识符或资源名称。URI中由正斜杠（'/'）分隔的部分代表了资源的层次结构。例如：`https://apis.newegg.org/so/v1/orders/12345678`。其中：
- 根路径： https://apis.newegg.org/so/v1/  
- 父资源名称： https://apis.newegg.org/so/v1/orders
- 子资源名称： https://apis.newegg.org/so/v1/orders/12345678

资源通常使用名称形式。为了使资源名称具有可读性，只有在必要时才使用[UUID](https://tools.ietf.org/html/rfc4122)。


## 资源建模（Resource Modeling）
设计REST API的第一步是设计资源模型。这个过程类似于对一个关系数据库系统的数据建模，或对一个面向对象系统的对象建模。资源模型识别和归类所有客户需要和服务进行交互的资源。目的是找出值得识别、呈现和操作的资源。  


### 复合资源（Composites）
由两种以上的资源构成。通常是为了减少客户端HTTP请求次数而将关联数据引入主请求资源。例如，订单资源可能在内部实现为关系数据库中的多个表，但作为单个实体呈现给客户。例如在Customer资源中引入Billing Address资源和Shipping Address资源。  
复合资源通常只用于查询。


### 抽象资源（Abstract Resources）
1）某些操作无法映射到普通的HTTP方法上，例如计算运费，校验信用卡等。这时可将对应的处理函数抽象成一个资源，例如shipping-calculator，credit-card-validator。因为这类方法是安全和幂等的，GET方法最适合的。  

2）为了将更新多个资源的操作作为原子操作处理，或者能够使客户触发一系列复杂的业务操作，可以创建Controller资源。例如：Void SO操作，假设需要1）更新Sales Order资源，2）发送Email给客户。与其分别更新`/orders/{order#}`资源和添加`/orders/{order#}/emails`资源，可以设计一个Controller资源`/orders/cancellation/{order#}`来处理Void SO 操作。


### 资源粒度（Resource Granularity）
资源粒度过细，会产生大量的API并使API碎片化。客户有可能需要发送多个API请求来完成一件事情。大量API请求也可能对服务端和网络负载造成压力。

资源粒度过粗，即：在一个资源中包含大量的数据和关系，有可能无法满足客户灵活多变的需求，或者因单次API传输的数据量过大而影响性能。

应该从客户和网络的角度来确定合适的资源粒度。需要考虑的其他因素还有：
- 缓存(Cacheability)
- 变化频率(Frequency of change)
- 可变性(Mutability)等

例如：客户和地址。是把地址数据作为客户资源的一部分，还是把客户和地址作为两个不同的资源呢？  
  1）如果我们要把客户缓存到gateway上面，包含地址数据可能就太大了。  
  2）如果我们需要在所有的客户地址中进行查询，就有必要把地址暴露成单独的资源。  


### 资源关联（Resource Relations）
资源关联可以使用子资源，用资源的层次结构来表示。例如：  
```
/orders/{order#}  //订单资源
/orders/{order#}/line-items  //订单Items资源，是/orders/{order#}的子资源
```
通常资源层级不能太多。不算跟路径，资源层级<=3是合理的。


### 关于Tunneling
Tunneling: 用同一URI，使用同样的方法，来完成不同的事情。例如：
```
POST /books/1234
op=updateDiscount&discount=15

POST /books/1234
op=30dayOffer&ebook_from=...
```
Tunneling削弱了协议级别（protocol-level）的可见性(visibility)，因为请求的可见部分如URI，HTTP方法，HTTP头和媒体类型(media types)无法无歧义地描述一个操作。

宁可使用一个单独资源(例如抽象资源)，也要尽量避免Tunneling。
