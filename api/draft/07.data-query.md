# 数据查询（Data Query）
查询是`HTTP GET`方法最普遍的应用。针对极其复杂的查询也可使用`POST`方法。不过，通常 `POST`方法没有缓存机制，因此不是查询数据的首选。


## TL;DR
1） 使用查询参数来指定过滤条件、排序字段或返回字段列表等  
2） 查询参数的排列顺序尽可能保持不变  
3） 如果客户没有设置查询参数，服务返回默认视图  
4） 为普遍使用的查询预定义命名查询  
5） 服务要假设所有查询参数都是可以省略的，并在客户省略查询参数的情况下提供默认视图。  
6） 服务需要忽略多余的参数。。  
7） 提供通过HTTP Link头提供翻页机制  
8） 对于隐藏内容，明确申明，不要让用户以为是服务端配置问题  
9） 如果字段较多，考虑支持fields参数  
10） 考虑支持标题扩展功能以支持返回子对象更详细的信息  
11） 文档化每一个查询参数  


## 查询方法（Query Methods）
查询设计可以考虑以下两个选项：
- GET + URI参数。但需尊重客户端、网关和服务器对URI长度的限制。
- POST + 消息体。前提是GET+URI参数的方式不可行。API文档必须清楚表明其蕴含的"GET WITH BODY"语义。

使用HTTP标头（header）来传输长的结构化的请求信息不是一个选择。从概念的角度来看，操作的语义应该始终由资源名称和查询参数表示，即URI中的内容。请求标头通常用于保留通用的上下文信息，例如`x-client-url`，`x-gateway-server`，`x-source-ip`等。另外，查询参数和标题的大小限制是不可靠的，取决于客户端，网关，服务器和实际设置。因此，不要利用HTTP标头来传递查询参数。


### 通过GET查询
GET通过URI的Query String来传递查询参数。查询参数包括过滤条件、排序字段、返回字段列表、返回记录数等。  
例如：按Invoice日期排序，从第80张invoice开始，返回20张invoices：  
`/order?offset=80&limit=20&orderBy=OrderDate`

查询参数的不同排列和组合会导致不同的URI。太多的URI会降低缓存的有效性。所以查询参数的排列顺序尽可能保持不变。


### 通过POST查询
如果查询条件太长使得URI超出浏览器或服务器对URI长度的限制，可以使用POST方法来执行查询。选择合适的`Content-Type`，例如`application/json`，`application/xml`或者`application/x-www-form-urlencoded`。

使用`application/x-www-form-urlencoded`示例：  
```
// GET WITH BODY
POST /order                       
Content-Type: application/x-www-form-urlencoded
zipcode=91765 & status=’V’        //payload

// Response
HTTP/1.1 200 OK
Content-Type: application/xml; charset=UTF-8
…
```
使用POST方法来获取资源的坏处：  
- 削弱了REST的“统一接口”原则  
- 返回结果不能缓存  


#### 存储查询（Store Queries）
通过POST方法执行的查询，可以首先创建一个关于该查询的新资源，然后利用GET 方法去访问该查询资源。这样POST查询就转成了GET查询。例如：
```
// Request #1
POST /order
Content-Type: application/x-www-form-urlencoded
zipcode=91765 & status=’V’    //payload

// Response
HTTP/1.1 201 Created
Content-Type: application/xml; charset=UTF-8
Location: .../order/query/1  //资源创建成功后，返回代码201（Created）以及一个指向新资源的Location头。  

Request #2
GET /order/query/1?offset=10
```
存储查询模式的好处是：
- 查询的结果是可缓存的。
- 任何同样的查询都可通过重定向到该资源的URI得以执行。
- 而且，该查询还可以接收新的条件。



## 查询参数（Query Parameters）
查询参数最主要用来返回资源集合，不应用来提供资源ID和任何操作指示。将资源ID嵌入查询字符串的问题之一是系统不再能根据URI来判断是否同一资源。例如：  
```
1) GET	/order/123456                //如果Order# 123456不存在，返回404  
2) GET	/order?orderNumber=123456    //如果Order# 123456不存在，返回空集合
```

查询参数也是资源唯一标识符的一部分。和URI的其他元素不同，查询部分对客户应该是透明的。
应使用HTTP头，而不是查询参数来确定Cache行为。


### 标准查询参数
为了保持各子系统统一接口和风格，有必要约定参数命名。

- HTTP头相关  
小写的HTTP头名称。例如：accept;??   

- 业务对象相关  
一般和字段命名相同，尽量和业界规范保持一致，各子系统务必统一。例如：customerNumber, orderNumber, vendorNumber,  

- 日期、时间相关  
  - 起始/截止日期：dateFrom, dateTo
  - 起始/截止时间：timeFrom, timeTo  
例如：订单起始/截止日期：orderDateFrom，orderDateTo  

- 控制有关   
  - 选择字段：fields= {return fields}  
  - 排序：sort= asc/desc  （排序方向）（也有用+/-来表示排序方向的，例如： /sales-orders?sort=+id）
  -	sortFields (字段用逗号分隔)
  -	视图：view= summary/ meta/ status/ …
  -	预定义查询：query={pre-defined query}
  -	返回记录数：limit= 100
  -	第n页：pageIndex={n}   pageSize
  -	第n条记录：startIndex={n}
  -	方法：method= delete
  -	展开子集合expand= order/ order.items/ …
  -	返回格式：format
  - 过滤 filter

q- 默认查询参数
offset - 基于数字的开始页。和limit结合，可用page代替offset
offset=50 means, ‘skip the first 50 records’  
limit=25 means, ‘return a maximum of 25 records’  
If no limit is specified, return results with a default limit.  


### 多值查询
只有csv或multi格式应该用于多值查询参数：

|收集格式|描述|Example|
|------|------|------|
|csv  |逗号分隔值  |?parameter=value1,value2,value3  |
|multi  |多个参数实例 |?parameter=value1&parameter=value2&parameter=value3  |

提供一组值作为查询参数有不同的方法。一个特定的类型应该在API定义中明确地选择和陈述。


### 服务端对参数的处理
服务要默认所有查询参数都是可以省略的，并在客户省略查询参数的情况下提供参数的默认值或默认行为（对于确实不能省略的查询参数，返回明确的错误信息）

服务需要忽略多余的参数。


## 查询数据返回
- 服务需要对返回的记录总数进行限制（用户已指定最大返回记录数除外）。  
请求单个资源，如果资源不存在，返回404
请求集合资源，如果返回列表为空，返回200；如果列表缺少，返回404.
请求集合资源时，应提供足够的过滤（filter)机制以及分页（Pagination）。 响应消息中包含资源List的字段的名称必须是资源名称本身的复数形式。

Provide filtering, sorting, field selection and paging for collections  

Information about record limits and total available count should also be included in the response.
```
HTTP/1.1 200 OK
Vary: Accept
Content-Type: text/javascript

{
  "metadata": {
    "resultset": {
      "count": 227,
      "offset": 25,
      "limit": 25
    }
  },
  "results": [...]
}
```

请求和响应应该共享相同的Content-Type，除非请求是GET或具有“ application/x-www-form-urlencoded body”的POST 。


## 和查询相关的常见设计模式
### 让客户端决定需要返回的数据
避免传输、解析和存储不需要的数据。  


#### 字段选择（Fields Selection）
字段选择也称为部分响应(Partial Response)。API客户端可以使用URI查询参数`fields`来指定需返回的字段列表。  
例如：`/order？fields=OrderNumber，CustomerNumber，OrderDate`。

更多示例：  
```
Facebook：  
https://graph.facebook.com/bgolub?fields=id,name,picture  
Google:   
https://www.googleapis.com/demo/v1?fields=kind,items(title,characteristics/length)
```

##### `fields`语法
用`,`来分隔多个字段；用`（）`来选择子字段。例如：
```
fields=name,breed,age
fields=name,breed,age,owner(name,age)
```

注：Google是最早引入`Partial Response`概念的公司之一。参考：  
- [Making APIs Faster: Introducing Partial Response and Partial Update](http://googlecode.blogspot.ca/2010/03/making-apis-faster-introducing-partial.html)
- [Google Site Verification API: Performance Tips](https://developers.google.com/site-verification/v1/performance)


#### 资源视图（Resource View）
资源视图指的是服务端预定义多个可以返回的字段组（groups of fields）。客户端可以通过查询参数`view`来指定需要返回哪一组字段。如果没有指定，则返回默认的字段组。例如：  
```
/order？view=master
/order？view=master-detail
/order？view=master-detail-tracking
https://library.googleapis.com/v1/shelves/shelf1/books?view=BASIC （Google)
```

`view`参数应该是`enum`类型。需在API文档中清楚说明`view`的取值范围。


#### 资源扩展（Resource Expansion）
除了返回默认字段外，客户端可以通过查询参数`expand`来指定一个或多个（用逗号分隔）需要返回详细信息的子资源列表。例如：  
```
/order？expand=tracking            // 返回的order数据中包含tracking信息
/order？expand=customer,tracking   // 返回的order数据中包含customer profile和tracking信息
```

需在API文档中清楚说明`expand`的取值范围。同时也可以使用父对象的`expand`属性来指示客户端哪些属性是可以扩展的。例如[Jira API](https://developer.atlassian.com/cloud/jira/platform/rest/#expansion)：   
```
{
  "expand": "widgets",  // Declares widgets as expandable.
  "self": "http://www.example.com/jira/rest/api/resource/KEY-1",
  "widgets": {
    "widgets": [],
    "size": 5
   }
}
```

##### `expand`语法
用`,`来分隔多个实体；用`（）`来选择嵌套实体。例如：
```
expand=widgets,widgets(fringels) //扩展widgets集合和widgets的fringels属性
```


#### 分页（Pagination）
如果列表中含有几百个以上记录，应支持分页以使客户端获得最佳的批处理和遍历体验。如果客户端未指定分页参数，则服务端需要限制每页允许返回的最大记录数（即`limit`查询参数的默认值）。  

最常见的两种页面遍历技术：基于偏移（Offset）的分页和基于游标(Cursor)的分页。

- 基于偏移（Offset）的分页  
用数字偏移标识第一个页面入口。通常`offset`指页面的起始位置；`limit`指需返回的记录数。 例如：`/order?offset=0&limit=10`.  

- 基于游标(Cursor)的分页  
基于Key的分页。一个唯一key标识第一个页面入口。例如（参见：[Facebook’s guide](https://developers.facebook.com/docs/graph-api/using-graph-api/v2.4#paging)）：
```
"paging": {
  "cursors": {
    "after": "MTAxNTExOTQ1MjAwNzI5NDE=",
    "before": "NDMyNzQyODI3OTQw"
  },
  "previous": "https://graph.facebook.com/me/albums?limit=25&before=NDMyNzQyODI3OTQw"
  "next": "https://graph.facebook.com/me/albums?limit=25&after=MTAxNTExOTQ1MjAwNzI5NDE="
}
```

应优先选择基于游标的分页，避免基于偏移的分页。与基于偏移量的分页相比，基于游标的分页通常更好并且更高效，特别是当涉及到高数据量以及NoSQL数据库存储时。使用基于偏移量的分页的高效服务器端处理几乎不可行。但当需要结果总数和/或反向迭代支持，则基于游标的导航可能无法正常工作。支持结果总数有可能对性能影响很大。  

分页的技术概念还应该考虑用户体验相关的问题。通常，相较于next/previous导航，跳转到特定页面的使用场景要少见得多。 （参见：[Infinite Scrolling, Pagination Or “Load More” Buttons? Usability Findings In eCommerce](https://www.smashingmagazine.com/2016/03/pagination-infinite-scrolling-load-more-buttons/))

更多阅读：  
- [Twitter](https://developer.twitter.com/en/docs/tweets/timelines/overview)
- [Use the Index, Luke](http://use-the-index-luke.com/no-offset)
- [Paging in PostgreSQL](https://www.citusdata.com/blog/2016/03/30/five-ways-to-paginate/)


### Filtering
限制任何单个请求返回的数据量

例如，假设客户端应用程序需要以超过特定值的成本查找所有订单。 它可能会从/ orders URI中检索所有订单，然后在客户端过滤这些订单。 很明显，这个过程非常低效。 它浪费了托管Web API的服务器上的网络带宽和处理能力。   
相反，API可以允许在URI的查询字符串中传递过滤器，例如/ orders？minCost = n   
```
GET /cars?color=red Returns a list of red cars
GET /cars?seats<=2 Returns a list of cars with a maximum of 2 seats
```



### 结果排序（Result Ordering）(Sorting Order)

排序顺序（Sorting Order）  
如果API方法允许客户端为列表结果指定排序顺序，则请求消息应包含一个字段：string order_by = ...;

字符串值应遵循SQL语法：逗号分隔的字段列表。 例如： "foo,bar" 。 默认的排序顺序是升序。 要指定字段的" desc" 应在字段名称后附加后缀" desc" 。 例如： "foo desc,bar" 。

语法中的冗余空格字符不重要。 "foo,bar desc"和" foo , bar desc "等价。

`GET /cars?sort=-manufactorer,+model`

通过提供一个将字段名称作为值的排序参数，例如/ orders？sort = ProductID ，您可以使用类似的策略对数据进行排序。 但是，这种方法会对缓存产生负面影响，因为查询字符串参数形成了许多缓存实现所使用的资源标识符的一部分，作为缓存数据的关键。

string order_by = ...;


### 其他
在查询字符串中给出所有可选参数有意义的默认值. 例如，如果您实现分页，则将limit参数设置为10，将offset参数设置为0;如果您执行排序，则将sort参数设置为资源的键;如果支持投影(projections)，则将fields参数设置为资源中的所有字段。
